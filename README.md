
#《深入理解C指针》笔记

第一章 认识指针
----------------------------------
### C程序的内存使用形式

| 内存方式 | 作用域 | 生命周期|
| ------------- |:-------------:| -----:|
| 全局内存 | 整个文件 | 应用程序生命周期 |
| 静态内存 | 声明函数内部 | 应用程序生命周期 |
| 自动内存 | 声明函数内部 | 函数执行生命周期 |
| 动态内存 | 由引用该内存的指针决定 | 内存释放（人工） |

> **全局内存**：常见的全局变量
> **静态内存**：静态变量，例如`const int var`
> **自动内存**：常见的就是生命在函数体内的变量了，这是最常见的
> **动态内存**：通过指针创建的堆区域

### 常量与指针

| 指针类型 | 指针是否可修改 | 指针指向数据是否可修改|
| ------------- |:-------------:| -----:|
| 指向非常量的    指针( int * ptr ) | 是 | 是 |
| 指向  常量的    指针( const int * ptr ) | 是 | 否 |
| 指向非常量的常量指针( int * const ptr ) | 否 | 是 |
| 指向  常量的常量指针( const int * const ptr ) | 否 | 否 |

> 阅读指针声明的时候，采取从右往左读的方式。
> 
> `* pci` - pci是个指针
> 
> `int * pci` - pci是个指向整数的指针
> 
> `const int * pci` - pci是个指向整数常量的指针，（指针可变，指针指向区域的整型数据不可变）

* `int const * p`与`const int * p`是等价的。可以按上面那种方式来读取。`const * p`是指向常量的指针,`int const * p`是指向整型常量的指针。
* `int * const p`是与上面不同的，`const p`意味着是常量，`* const p`则是常量指针，`int * const p`是指向整型的常量指针（指针不可变，指针指向区域的整型数据可变）
* 结合上面两种的形式是`const int * const * p`就是指针不可变，指针指向区域的数据也不可变

### 指针多层引用
* 多层指针通常与**多维数组**，**指针数组**等有关联，详细的放到**第四章 数组与指针**中进行详细记录

### 其他
* [指针的语法和语义规范](http://www.open-std.org/JTC1/SC22/WG14/)
* 指针的声明：声明指针时，例如`int * p`，`*`的位置是无所谓的，看个人习惯。
* `&`用来取值，`%p`来显示地址。
* 各平台显示地址方式不一定会一致。通过将要显示的指针转换为void指针来兼容各个平台，例如`print("p%",(void *) p)`
* 通过程序显示的地址均为在操作系统虚拟内存映射下的地址，并非真正的物理地址
* 在取地址和解地址的方面，`*`和`&`是互反的操作
* 在使用指针时，`NULL`和`0`都可以，但是`NULL`更好些，可以告诉开发者在使用指针。
* void指针是通用指针。void指针可以转换为除函数指针外的任何指针。
* `intprt_t`和`uintptr_t`是C99标准为了适应64位环境所新增的。暂时可以不用了解
* 指针相加的实质是按声明类型字节大小进行步增
* 指针相减的实质是两个指针地址相减后，按声明类型字节大小整除后得到的**单位**值，并通过符号老判断地址前后顺序


